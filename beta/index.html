<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFL Team Owners Standings</title>

    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            color: #2c3e50;
            margin-bottom: 10px;
        }



        .standings-table {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background-color: #2c3e50;
            color: white;
            padding: 15px 10px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        td {
            padding: 15px 10px;
            text-align: center;
            border-bottom: 1px solid #ecf0f1;
        }

        tr:hover {
            background-color: #f8f9fa;
        }



        .rank {
            font-weight: bold;
            color: #2c3e50;
        }

        .owner-name {
            font-weight: 600;
            color: #34495e;
        }

        .record {
            font-weight: 500;
        }

        .team-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .team-info-stacked {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .team-logo {
            width: 35px;
            height: 35px;
            object-fit: contain;
        }

        .team-record {
            font-size: 0.85rem;
            color: #666;
        }

        .game-line {
            font-size: 0.7rem;
            color: #555;
            text-align: center;
            margin-top: 4px;
            line-height: 1.2;
            min-height: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 4px;
            border-radius: 4px;
        }

        .game-line.game-state-pre {
            background-color: #e3f2fd !important;
            border: 1px solid #bbdefb;
        }

        .game-line.game-state-in {
            /* Base neutral color for live games - will be overridden by win/loss classes */
            background-color: #f3f4f6 !important;
            border: 1px solid #d1d5db;
            animation: pulse-live 2s infinite;
        }

        .game-line.game-state-post {
            /* Base neutral color for completed games - will be overridden by win/loss classes */
            background-color: #f9fafb !important;
            border: 1px solid #e5e7eb;
        }

        /* Win/Loss/Tie color classes for live games */
        .game-line.game-state-in.game-winning {
            background-color: #dcfce7 !important;
            border: 1px solid #86efac;
        }

        .game-line.game-state-in.game-losing {
            background-color: #fee2e2 !important;
            border: 1px solid #fca5a5;
        }

        .game-line.game-state-in.game-tied {
            background-color: #fef3c7 !important;
            border: 1px solid #fcd34d;
        }

        /* Win/Loss/Tie color classes for completed games */
        .game-line.game-state-post.game-won {
            background-color: #dcfce7 !important;
            border: 1px solid #22c55e;
        }

        .game-line.game-state-post.game-lost {
            background-color: #fee2e2 !important;
            border: 1px solid #ef4444;
        }

        .game-line.game-state-post.game-tied {
            background-color: #fef3c7 !important;
            border: 1px solid #eab308;
        }

        .game-line.game-state-bye {
            background-color: #f5f5f5 !important;
            border: 1px solid #e0e0e0;
        }

        @keyframes pulse-live {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.7; }
        }

        .game-opponent {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .venue-icon {
            font-size: 0.6rem;
        }

        .game-time {
            color: #666;
            font-size: 0.65rem;
            margin-bottom: 1px;
        }

        .game-score {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.68rem;
        }

        .game-status {
            color: #e67e22;
            font-weight: 500;
            font-size: 0.65rem;
        }

        .game-final {
            font-weight: 600;
        }

        .game-final .win-indicator {
            color: #27ae60;
        }

        .game-final .loss-indicator {
            color: #e74c3c;
        }

        .game-live {
            color: #000000;
            font-weight: 600;
        }

        .team-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .team-record {
            font-size: 0.65rem;
            color: #666;
            margin-top: 2px;
        }

        /* Teams cell styling */
        .teams-cell {
            padding: 5px 4px;
        }

        .teams-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .owner-record {
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
            color: #2c3e50;
            margin-bottom: 4px;
            padding-bottom: 3px;
            border-bottom: 1px solid #ecf0f1;
        }

        .teams-grid {
            display: flex;
            flex-direction: row;
            gap: 6px;
            justify-content: center;
            align-items: flex-start;
        }

        .team-card {
            background-color: #f8f9fa;
            border-radius: 4px;
            padding: 6px 4px;
            min-width: 100px;
            text-align: center;
            border: 1px solid #e9ecef;
            transition: box-shadow 0.2s ease;
        }

        .team-card:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }



        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
            color: #666;
        }

        .error {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
            color: #e74c3c;
        }

        .last-updated {
            text-align: center;
            margin-top: 20px;
            color: #666;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 5px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .header {
                padding: 15px;
                margin-bottom: 15px;
            }

            /* Optimize table for mobile */
            .standings-table {
                font-size: 0.75rem;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            table {
                min-width: 100%;
                width: auto;
            }

            th, td {
                padding: 8px 3px;
                font-size: 0.7rem;
                white-space: nowrap;
            }

            th {
                font-size: 0.65rem;
                padding: 10px 3px;
            }

            /* Rank column */
            th:nth-child(1), td:nth-child(1) {
                width: 8%;
                min-width: 25px;
            }

            /* Owner column */
            th:nth-child(2), td:nth-child(2) {
                width: 12%;
                min-width: 40px;
                font-size: 0.65rem;
            }

            /* Record column */
            th:nth-child(3), td:nth-child(3) {
                width: 18%;
                min-width: 60px;
                font-size: 0.65rem;
            }

            /* Team logo columns */
            th:nth-child(4), th:nth-child(6), th:nth-child(8),
            td:nth-child(4), td:nth-child(6), td:nth-child(8) {
                width: 10%;
                min-width: 35px;
                padding: 5px 2px;
            }

            /* Team record columns */
            th:nth-child(5), th:nth-child(7), th:nth-child(9),
            td:nth-child(5), td:nth-child(7), td:nth-child(9) {
                width: 14%;
                min-width: 45px;
                font-size: 0.6rem;
            }

            .team-logo {
                width: 20px;
                height: 20px;
            }

            .rank {
                font-size: 0.7rem;
            }

            .owner-name {
                font-size: 0.65rem;
                font-weight: 600;
            }

            .record {
                font-size: 0.65rem;
            }



            .team-record {
                font-size: 0.6rem;
            }




        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>NFL Team Owners Standings</h1>
    </div>

    <div class="standings-table">
        <div id="loading" class="loading">Loading standings...</div>
        <div id="error" class="error" style="display: none;"></div>
        <table id="standings" style="display: none;">
            <thead>
            <tr>
                <th></th>
                <th></th>
            </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>

    <div class="last-updated" id="lastUpdated"></div>
</div>

<script>
    // Team to owner mapping
    const teamToOwner = {
        "ARI": "Jon",
        "ATL": "Cole",
        "BAL": "Jake",
        "BUF": "Ryan",
        "CAR": "Rohit",
        "CHI": "Nathan",
        "CIN": "Nathan",
        "CLE": "",
        "DAL": "John",
        "DEN": "Cody",
        "DET": "John",
        "GB": "Mike",
        "HOU": "Mike",
        "IND": "Jake",
        "JAX": "Jon",
        "LAC": "Rohit",
        "LAR": "Ossman",
        "LV": "Jake",
        "KC": "Rohit",
        "MIA": "Mike",
        "MIN": "Nathan",
        "NE": "Cole",
        "NO": "",
        "NYG": "Ossman",
        "NYJ": "Cody",
        "PHI": "Ossman",
        "PIT": "John",
        "SEA": "Ryan",
        "SF": "Cole",
        "TB": "Jon",
        "TEN": "Ryan",
        "WSH": "Cody"
    };

    // Initialize data structures
    const owners = ["Cody", "Cole", "Jake", "John", "Jon", "Mike", "Nathan", "Ossman", "Rohit", "Ryan"];
    const ownerToTeams = {};
    const ownerToRecord = {};
    const teamToStats = {};

    // Initialize owner data
    owners.forEach(owner => {
        ownerToTeams[owner] = [];
        ownerToRecord[owner] = { wins: 0, losses: 0, ties: 0 };
    });

    // ESPN API endpoint
    const espnStandingsUrl = "https://site.api.espn.com/apis/v2/sports/football/nfl/standings?seasontype=2";

    // Main function to generate rankings
    async function generateRanking() {
        try {
            await fetchAndAggregate();
            renderRanking();
            updateLastUpdated();
        } catch (error) {
            console.error('Error generating rankings:', error);
            showError('Failed to load standings. Please refresh the page.');
        }
    }

    // Fetch standings data
    async function fetchAndAggregate() {
        const response = await axios.get(espnStandingsUrl);
        const afcTeams = response.data.children[0].standings.entries;
        const nfcTeams = response.data.children[1].standings.entries;
        const allTeams = [...afcTeams, ...nfcTeams];

        allTeams.forEach(teamData => {
            const teamAbbreviation = teamData.team.abbreviation;
            const ownerName = teamToOwner[teamAbbreviation];

            if (ownerName) {
                teamToStats[teamAbbreviation] = teamData.stats;

                const teamSummary = {
                    abbreviation: teamAbbreviation,
                    id: teamData.team.id,
                    logos: teamData.team.logos,
                    wins: 0,
                    losses: 0,
                    ties: 0
                };

                teamData.stats.forEach(stat => {
                    if (stat.name === "wins") {
                        ownerToRecord[ownerName].wins += stat.value;
                        teamSummary.wins = stat.value;
                    } else if (stat.name === "losses") {
                        ownerToRecord[ownerName].losses += stat.value;
                        teamSummary.losses = stat.value;
                    } else if (stat.name === "ties") {
                        ownerToRecord[ownerName].ties += stat.value;
                        teamSummary.ties = stat.value;
                    }
                });



                ownerToTeams[ownerName].push(teamSummary);
            }
        });
    }



    // Calculate win percentage for an owner
    function calculateWinPercentage(wins, losses, ties) {
        const totalGames = wins + losses + ties;
        if (totalGames === 0) return 0;
        // NFL win percentage counts ties as half a win
        return ((wins + (ties * 0.5)) / totalGames) * 100;
    }

    // Get win percentage classification
    function getWinPctClass(winPct) {
        if (winPct >= 60) return 'win-pct-high';
        if (winPct >= 40) return 'win-pct-medium';
        return 'win-pct-low';
    }

    // Format win percentage display
    function formatWinPct(winPct) {
        return winPct.toFixed(1) + '%';
    }

    // Render the rankings table
    function renderRanking() {
        const ownerList = [];

        for (const [owner, record] of Object.entries(ownerToRecord)) {
            const winPct = calculateWinPercentage(record.wins, record.losses, record.ties);
            ownerList.push({
                owner,
                wins: record.wins,
                losses: record.losses,
                ties: record.ties,
                winPercentage: winPct
            });
        }

        // Sort by wins (descending)
        ownerList.sort((a, b) => b.wins - a.wins);

        // Clear table body
        const tableBody = document.getElementById('tableBody');
        tableBody.innerHTML = '';

        // Assign ranks with golf-style ranking for ties (tied players get LAST position they occupy)
        for (let i = 0; i < ownerList.length; i++) {
            let tiedCount = 1;
            // Count how many people are tied with this person
            for (let j = i + 1; j < ownerList.length; j++) {
                if (ownerList[j].wins === ownerList[i].wins) {
                    tiedCount++;
                } else {
                    break;
                }
            }
            
            // All tied players get the rank of the last position in the group
            const lastPositionRank = i + tiedCount;
            for (let k = i; k < i + tiedCount; k++) {
                ownerList[k].rank = lastPositionRank;
            }
            
            // Skip past the tied players
            i += tiedCount - 1;
        }

        ownerList.forEach((item, index) => {
            const record = `${item.wins} - ${item.losses} - ${item.ties}`;
            const teams = ownerToTeams[item.owner];

            // Sort teams by wins
            teams.sort((a, b) => b.wins - a.wins);

            // Create row
            const row = document.createElement('tr');

            // Combined Rank and Owner
            const rankOwnerCell = document.createElement('td');
            rankOwnerCell.innerHTML = `<span class="rank">${item.rank})</span> <span class="owner-name">${item.owner}</span>`;
            row.appendChild(rankOwnerCell);

            // Teams cell - containing record and teams layout
            const teamsCell = document.createElement('td');
            teamsCell.className = 'teams-cell';
            
            // Create teams container
            const teamsContainer = document.createElement('div');
            teamsContainer.className = 'teams-container';
            
            // Add owner record at top
            const ownerRecord = document.createElement('div');
            ownerRecord.className = 'owner-record';
            ownerRecord.textContent = record;
            teamsContainer.appendChild(ownerRecord);
            
            // Create teams grid
            const teamsGrid = document.createElement('div');
            teamsGrid.className = 'teams-grid';
            
            teams.forEach(team => {
                const teamCard = document.createElement('div');
                teamCard.className = 'team-card';
                teamCard.setAttribute('data-team', team.abbreviation);
                
                teamCard.innerHTML = `
                    <div class="team-info">
                        <img class="team-logo" src="${team.logos[0].href}" alt="${team.abbreviation}">
                        <div class="team-record">${team.wins} - ${team.losses} - ${team.ties}</div>
                    </div>
                    <div class="game-line">Loading...</div>
                `;
                
                teamsGrid.appendChild(teamCard);
            });
            
            teamsContainer.appendChild(teamsGrid);
            teamsCell.appendChild(teamsContainer);
            row.appendChild(teamsCell);

            tableBody.appendChild(row);
        });

        // Show table and hide loading
        document.getElementById('loading').style.display = 'none';
        document.getElementById('standings').style.display = 'table';
    }

    // Update last updated timestamp
    function updateLastUpdated() {
        const now = new Date();
        const timeString = now.toLocaleString('en-US', {
            weekday: 'short',
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
        document.getElementById('lastUpdated').textContent = `Last updated: ${timeString}`;
    }

    // Show error message
    function showError(message) {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
        document.getElementById('error').textContent = message;
    }

    // ===== GAME INFORMATION FUNCTIONS =====

    // Fetch current week's scoreboard data
    async function fetchScoreboard() {
        const res = await fetch('https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard', { cache: 'no-store' });
        if (!res.ok) throw new Error('Scoreboard fetch failed');
        return res.json();
    }

    // Index games by team abbreviation for quick lookup
    function indexGamesByTeam(scoreboardJson) {
        const byTeam = new Map(); // abbr -> event
        for (const ev of scoreboardJson.events || []) {
            const comp = ev.competitions?.[0];
            if (!comp) continue;
            for (const c of comp.competitors || []) {
                const abbr = c.team?.abbreviation;
                if (abbr) byTeam.set(abbr, ev);
            }
        }
        return byTeam;
    }

    // Normalize one team's view of a game
    function normalizeTeamGame(event, teamAbbr) {
        const comp = event.competitions[0];
        const status = comp.status?.type?.state; // 'pre'|'in'|'post'
        const period = comp.status?.period ?? null;
        const clock = comp.status?.displayClock ?? '';
        const desc = comp.status?.type?.description ?? '';
        const shortDetail = comp.status?.type?.shortDetail ?? '';
        const [home, away] = comp.competitors.sort((a,b)=> a.homeAway === 'home' ? 1 : -1);
        const isHome = home.team.abbreviation === teamAbbr;
        const self = isHome ? home : away;
        const opp = isHome ? away : home;
        const kickoffIso = event.date;
        const winnerAbbr = comp.competitors.find(x => x.winner)?.team?.abbreviation ?? null;

        return {
            state: status, period, clock, desc, shortDetail, kickoffIso,
            homeAbbr: home.team.abbreviation, awayAbbr: away.team.abbreviation,
            homeScore: home.score, awayScore: away.score,
            selfAbbr: teamAbbr, oppAbbr: opp.team.abbreviation,
            venueSide: isHome ? 'vs' : '@',
            winnerAbbr,
            eventId: event.id
        };
    }

    // Format game line HTML with enhanced styling and icons
    function formatTeamLineHTML(g) {
        const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
        const venueIcon = g.venueSide === 'vs' ? '🏠' : '✈️';
        
        if (g.state === 'pre') {
            const kickoffDate = new Date(g.kickoffIso);
            
            // Get shortened day of week (3 letters)
            const dayOfWeek = new Intl.DateTimeFormat(undefined, {
                weekday: 'short',
                timeZone: tz
            }).format(kickoffDate);
            
            // Get time
            const timeStr = new Intl.DateTimeFormat(undefined, {
                hour: 'numeric', minute: '2-digit',
                timeZone: tz
            }).format(kickoffDate);
            
            const kickoffStr = `${dayOfWeek} ${timeStr}`;
            
            return `
                <div class="game-opponent">
                    <span class="venue-icon">${venueIcon}</span>
                    ${g.venueSide} ${g.oppAbbr}
                </div>
                <div class="game-time">${kickoffStr}</div>
            `;
        }
        
        if (g.state === 'in') {
            // prefer descriptive states like Halftime when present
            let phase;
            if (g.desc && g.desc.toLowerCase().includes('half')) {
                phase = g.desc;
            } else if (g.shortDetail && !g.shortDetail.includes(g.clock)) {
                // Use shortDetail if it doesn't already contain the clock time
                phase = g.shortDetail;
            } else {
                // Build our own phase string to avoid duplication
                const quarterStr = g.period >= 5 ? 'OT' : `Q${g.period || ''}`;
                phase = quarterStr + (g.clock ? ` ${g.clock}` : '');
            }
            
            return `
                <div class="game-score game-live">${g.awayAbbr} ${g.awayScore} @ ${g.homeAbbr} ${g.homeScore}</div>
                <div class="game-status game-live">${phase}</div>
            `;
        }
        
        if (g.state === 'post') {
            let wlFormatted = '';
            if (g.winnerAbbr) {
                const isWin = g.winnerAbbr === g.selfAbbr;
                const wlClass = isWin ? 'win-indicator' : 'loss-indicator';
                const wlText = isWin ? '(W)' : '(L)';
                wlFormatted = `<span class="${wlClass}">${wlText}</span>`;
            }
            
            return `
                <div class="game-score">${g.awayAbbr} ${g.awayScore} @ ${g.homeAbbr} ${g.homeScore}</div>
                <div class="game-status game-final">Final ${wlFormatted}</div>
            `;
        }
        
        // fallback (e.g., canceled)
        return `
            <div class="game-opponent">
                <span class="venue-icon">${venueIcon}</span>
                ${g.venueSide} ${g.oppAbbr}
            </div>
            <div class="game-status">${g.desc || '—'}</div>
        `;
    }

    // Determine game outcome class based on score
    function getGameOutcomeClass(g) {
        if (g.state === 'pre') return ''; // No outcome for pre-game
        
        const selfScore = g.selfAbbr === g.homeAbbr ? parseInt(g.homeScore) : parseInt(g.awayScore);
        const oppScore = g.selfAbbr === g.homeAbbr ? parseInt(g.awayScore) : parseInt(g.homeScore);
        
        if (selfScore > oppScore) {
            return g.state === 'in' ? 'game-winning' : 'game-won';
        } else if (selfScore < oppScore) {
            return g.state === 'in' ? 'game-losing' : 'game-lost';
        } else {
            return 'game-tied'; // Same class for both live ties and completed ties
        }
    }

    // Render game lines under team cells with state classes
    function renderLines(byTeam) {
        document.querySelectorAll('[data-team]').forEach(el => {
            const abbr = el.getAttribute('data-team');
            const event = byTeam.get(abbr);
            const target = el.querySelector('.game-line');
            if (!target) return;
            
            // Clear existing state classes
            target.className = 'game-line';
            
            if (!event) {
                target.innerHTML = '<div class="game-status">BYE</div>';
                // Add BYE state for neutral background
                target.classList.add('game-state-bye');
            } else {
                const g = normalizeTeamGame(event, abbr);
                
                // Add appropriate state class for background color
                const stateClass = `game-state-${g.state}`;
                target.classList.add(stateClass);
                
                // Add win/loss/tie class for coloring
                const outcomeClass = getGameOutcomeClass(g);
                if (outcomeClass) {
                    target.classList.add(outcomeClass);
                }
                
                target.innerHTML = formatTeamLineHTML(g);
            }
        });
    }

    // Main tick function to update game info
    async function tickGameInfo() {
        try {
            const data = await fetchScoreboard();
            const byTeam = indexGamesByTeam(data);
            renderLines(byTeam);
        } catch (e) {
            console.error('Game info update failed:', e);
            // Show error in game lines
            document.querySelectorAll('.game-line').forEach(el => {
                el.textContent = 'Error';
            });
        }
    }

    // Initialize game info polling
    function startGameInfoPolling() {
        tickGameInfo(); // Initial load
        setInterval(tickGameInfo, 30000); // Update every 30 seconds
    }

    // Initialize on page load - updated ranking logic and game info
    window.addEventListener('DOMContentLoaded', async () => {
        await generateRanking();
        startGameInfoPolling();
    });
</script>
</body>
</html>
